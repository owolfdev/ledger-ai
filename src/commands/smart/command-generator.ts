// src/commands/smart/command-generator.ts

import type { CommandMeta } from "./utils";
import { getCommandContext, extractCommandSyntax } from "./utils";

export interface CommandGenerationResult {
  success: boolean;
  command: string;
  confidence: number;
  reasoning: string;
  error?: string;
}

export class CommandGenerator {
  private commandRegistry: Record<string, CommandMeta>;

  constructor(commandRegistry: Record<string, CommandMeta>) {
    this.commandRegistry = commandRegistry;
  }

  async generateCommand(
    naturalLanguageInput: string,
    potentialCommands: string[] = []
  ): Promise<CommandGenerationResult> {
    try {
      // Build context for AI
      const context = this.buildAIContext(potentialCommands);

      // Call OpenAI API
      const response = await fetch("/api/openai-command", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          input: naturalLanguageInput,
          context: context,
          potentialCommands: potentialCommands,
        }),
      });

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`);
      }

      const result = await response.json();

      if (!result.command) {
        return {
          success: false,
          command: "",
          confidence: 0,
          reasoning: "AI did not generate a command",
          error: result.error || "No command generated",
        };
      }

      // Validate the generated command
      const validation = this.validateGeneratedCommand(result.command);

      return {
        success: validation.isValid,
        command: validation.isValid ? result.command : "",
        confidence: validation.isValid ? result.confidence || 0.7 : 0,
        reasoning: validation.isValid
          ? result.reasoning || "Generated by AI"
          : validation.reason,
        error: validation.isValid ? undefined : validation.reason,
      };
    } catch (error) {
      return {
        success: false,
        command: "",
        confidence: 0,
        reasoning: "Failed to generate command",
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  private buildAIContext(potentialCommands: string[]): string {
    // Get relevant commands (either potential ones or most commonly used)
    const relevantCommands =
      potentialCommands.length > 0
        ? potentialCommands
        : ["new", "entries", "edit-entry"]; // Default high-priority commands

    const commandContexts = relevantCommands
      .filter((cmd) => this.commandRegistry[cmd])
      .map((cmd) => getCommandContext(cmd, this.commandRegistry[cmd]))
      .join("\n\n");

    const systemContext = `
You are a command generator for a Ledger App terminal system. Your job is to convert natural language input into proper terminal commands.

AVAILABLE COMMANDS:
${commandContexts}

IMPORTANT RULES:
1. Only generate commands that exist in the registry above
2. Use the exact syntax shown in the command usage
3. Always validate amounts are numeric
4. Use proper flag syntax (--flag or -f)
5. For expenses, prefer the "new" command
6. For queries, prefer the "entries" command
7. For edits, prefer the "edit-entry" command

COMMON PATTERNS:
- "I bought coffee for 150 baht" → "new -i coffee 150"
- "I spent $20 at Starbucks" → "new -i coffee 20 --vendor Starbucks"
- "I received $5000 for consulting" → "new -i consulting 5000 --type income --client Acme Corp"
- "Bought a laptop for $2000 with credit card" → "new -i laptop 2000 --type asset --payment credit-card"
- "Bought a laptop from Apple Store on my KBank Credit card" → "new -i laptop 40000 --type asset --vendor Apple Store --payment KBank Credit card"
- "Paid off $500 of credit card debt" → "new -i credit-card 500 --type liability --payment checking"
- "Opening balance of 1000000 in my Kasikorn bank account" → "new -i opening_balance 1000000 --type asset --payment Kasikorn Bank"
- "Show me today's expenses" → "entries today"
- "How much did I spend on coffee?" → "entries -v coffee -s"
- "MyBrick: office supplies $100" → "new -i supplies 100 --business MyBrick"

Return ONLY the command, nothing else. If you cannot generate a valid command, return "ERROR: [reason]".
    `.trim();

    return systemContext;
  }

  private validateGeneratedCommand(command: string): {
    isValid: boolean;
    reason: string;
  } {
    // Basic validation
    if (!command || command.trim() === "") {
      return { isValid: false, reason: "Empty command" };
    }

    // Check for error responses
    if (command.startsWith("ERROR:") || command.startsWith("error:")) {
      return { isValid: false, reason: command.replace(/^ERROR:\s*/i, "") };
    }

    // Extract the base command
    const parts = command.trim().split(/\s+/);
    const baseCommand = parts[0];

    // Check if the base command exists in registry
    if (!this.commandRegistry[baseCommand]) {
      return { isValid: false, reason: `Unknown command: ${baseCommand}` };
    }

    // Additional validation for specific commands
    if (baseCommand === "new") {
      return this.validateNewCommand(command);
    }

    if (
      baseCommand === "entries" ||
      baseCommand === "ent" ||
      baseCommand === "e"
    ) {
      return this.validateEntriesCommand(command);
    }

    if (baseCommand === "edit-entry" || baseCommand === "editent") {
      return this.validateEditCommand(command);
    }

    // For other commands, basic validation is sufficient
    return { isValid: true, reason: "Valid command" };
  }

  private validateNewCommand(command: string): {
    isValid: boolean;
    reason: string;
  } {
    // Check for basic structure - should have item and amount
    const hasAmount = /\d+(?:\.\d+)?/.test(command);
    if (!hasAmount) {
      return { isValid: false, reason: "New command requires an amount" };
    }

    // Check for dangerous patterns
    if (this.containsDangerousPatterns(command)) {
      return { isValid: false, reason: "Command contains unsafe patterns" };
    }

    return { isValid: true, reason: "Valid new command" };
  }

  private validateEntriesCommand(command: string): {
    isValid: boolean;
    reason: string;
  } {
    // Entries commands are generally safe, just check for dangerous patterns
    if (this.containsDangerousPatterns(command)) {
      return { isValid: false, reason: "Command contains unsafe patterns" };
    }

    return { isValid: true, reason: "Valid entries command" };
  }

  private validateEditCommand(command: string): {
    isValid: boolean;
    reason: string;
  } {
    // Edit commands should have an ID
    const hasId = /edit-entry\s+\d+|editent\s+\d+/.test(command);
    if (!hasId) {
      return {
        isValid: false,
        reason: "Edit command requires a numeric entry ID",
      };
    }

    // Check for dangerous patterns
    if (this.containsDangerousPatterns(command)) {
      return { isValid: false, reason: "Command contains unsafe patterns" };
    }

    return { isValid: true, reason: "Valid edit command" };
  }

  private containsDangerousPatterns(command: string): boolean {
    const dangerousPatterns = [
      /[;&|`$(){}]/, // Shell injection patterns
      /\.\./, // Directory traversal
      /rm\s/i, // Dangerous commands
      /delete\s/i, // Be careful with delete
      /drop\s/i, // Database operations
      /truncate\s/i, // Database operations
      /exec\s/i, // Command execution
    ];

    return dangerousPatterns.some((pattern) => pattern.test(command));
  }
}
